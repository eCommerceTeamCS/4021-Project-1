---
title: "Project 2"
author: "Shayne Cassidy, Sarah Nelson, Sarah Winston Nathan"
date: "12-6-2019"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
require("knitr")
#datadir <- "/Users/shaynecassidy/Desktop/4021/Data/AirQualityUCI"
#sourcedir <-"/Users/shaynecassidy/Desktop/4021/RCode"

# sourcedir <- "C:/Users/swnathan/Documents/4y1s/sys4021/InClassR/RCode"
# datadir <- "C:/Users/swnathan/Documents/4y1s/sys4021/InClassR/Data/AirQualityUCI"
sourcedir <- "C:/Users/student/SYS4021/RCode"
datadir <- "C:/Users/student/SYS4021/Data/AirQualityUCI/"
opts_knit$set(root.dir = sourcedir)
library(forecast)
library(mtsdi)
library(MTS)
```

# Load data and impute missing values
```{r, warning=FALSE}
setwd(datadir)
airquality = read.csv('AirQualityUCI.csv')

# replace -200 with NA
airquality[airquality == -200] <- NA

# convert integer type to numeric
intcols = c(4,5,7,8,9,10,11,12)
for(i in 1:length(intcols)){
  airquality[,intcols[i]] <- as.numeric(airquality[,intcols[i]])
}

setwd(sourcedir)

# create new data frame with just CO and NO2
AQdata = airquality[,c(3,10)]

# impute missing air quality data
f <- ~ CO.GT. + NO2.GT.
t <- c(seq(1,dim(AQdata)[1],1))
i <- mnimput(f, AQdata, eps=1e-3, ts=TRUE, method='gam', 
             ga.control=list(formula=paste(names(AQdata)[c(1:3)],'~ns(t,2)')))

# set airquality to imputed data
AQdata <- i$filled.dataset

# aggregate to daily maxima for model building
dailyAQ <- aggregate(AQdata, by=list(as.Date(airquality[,1],"%m/%d/%Y")), FUN=max)

# remove last 7 days
dailyAQ <- dailyAQ[1:(dim(dailyAQ)[1]-7),]
```


### Part 1: Building Univariate Time Series Models
```{r}
AQ.CO <- dailyAQ$CO.GT.
#AQ.CO <- AQdata$CO.GT.
AQ.NO2 <- dailyAQ$NO2.GT.
#AQ.NO2<-AQdata$NO2.GT.

CO.ts<-ts(AQ.CO)
NO2.ts<-ts(AQ.NO2)

plot(CO.ts)
plot(NO2.ts)
```

# Part A: Seasonality 
```{r}
acf(CO.ts)
acf(NO2.ts)
# both show sinusoidal exponential decay --> AR model

pg.CO <- spec.pgram(CO.ts,spans=9,demean=T,log='no')
# spikes in periodagram at repeated frequencies --> indicates seasonality present
max.pg.CO<-pg.CO$freq[which(pg.CO$spec==max(pg.CO$spec))]

# Where is the peak? -->0.002604167
max.pg.CO

# What is the period? -->384
1/max.pg.CO
```
```{r}
pg.NO2 <- spec.pgram(NO2.ts,spans=9,demean=T,log='no')
# spikes in periodagram at repeated frequencies --> indicates seasonality present
max.pg.NO2<-pg.CO$freq[which(pg.NO2$spec==max(pg.NO2$spec))]

# Where is the peak? -->0.00520833
max.pg.NO2

# What is the period? -->192
1/max.pg.NO2

# What are the periods of the next biggest peaks?
# sort spectrum from largest to smallest and find index
sorted.spec <- sort(pg.CO$spec, decreasing=T, index.return=T)
names(sorted.spec)

# corresponding periods
sorted.omegas <- pg.NO2$freq[sorted.spec$ix]
sorted.Ts <- 1/pg.NO2$freq[sorted.spec$ix]

# look at first 20
sorted.omegas[1:20]
sorted.Ts[1:192]
# evens around 7
period<-7 
```

# Part B: Trends
```{r}
# Build a new model, CO.trend which predicts CO.ts based on the time variable
time<-c(1:(length(CO.ts)))
CO.trend<-lm(CO.ts ~ time)
NO2.trend<-lm(NO2.ts ~ time)

summary(CO.trend)
summary(NO2.trend)
```
# Plot CO.trend model
```{r}
{plot(time, CO.ts, type = "l")
abline(CO.trend, col = "red")}
```
# Plot NO2.trend model
```{r}
{plot(time, NO2.ts, type = "l")
abline(NO2.trend, col = "red")}
```
# Model diagnostics for CO.trend
```{r}
par(mfrow=c(2,2))
plot(CO.trend, labels.id = NULL)
par(mfrow=c(1,1))
```
# Model diagnostics for NO2.trend
```{r}
par(mfrow=c(2,2))
plot(NO2.trend, labels.id = NULL)
par(mfrow=c(1,1))
```
# add seasonality component to CO.trend
```{r}
CO.trend.seasonal <- lm(CO.ts[time] ~ time + sin(2*pi*time/365) + cos(2*pi*time/365))
summary(CO.trend.seasonal)
```
# add seasonality component to NO2.trend
```{r}
NO2.trend.seasonal <- lm(NO2.ts[time] ~ time + sin(2*pi*time/365) + cos(2*pi*time/365))
summary(NO2.trend.seasonal)
```
# Model diagnostics for CO.trend.seasonal
```{r}
par(mfrow=c(2,2))
plot(CO.trend.seasonal, labels.id = NULL)
par(mfrow=c(1,1))
```
# Model diagnostics for NO2.trend.seasonal
```{r}
par(mfrow=c(2,2))
plot(NO2.trend.seasonal, labels.id = NULL)
par(mfrow=c(1,1))
```

## Part C: Auto-Regressive and Moving Average
#Get the residuals from the CO.trend.seasonal model above and store in e.ts:
```{r}
e.ts.CO<-ts(CO.trend.seasonal$residuals)
```
#Get the residuals from the NO2.trend.seasonal model above and store in e.ts:
```{r}
e.ts.NO2<-ts(NO2.trend.seasonal$residuals)
```
#Plot the residuals for the CO.trend.seasonal model NO2.trend.seasonal
```{r}
plot(e.ts.CO, ylab = "Residuals from CO Model")
plot(e.ts.NO2, ylab = "Residuals from NO2 Model")
```
# Plot the autocorrelation (ACF) and partial autocorrelation (PACF) of the residuals of CO.trend.seasonal
```{r}
par(mfrow=c(1,2))
acf(e.ts.CO, main="ACF of Residuals\nfrom CO.trend.seasonal")
pacf(e.ts.CO,main="PACF of Residuals\nfrom CO.trend.seasonal")
par(mfrow=c(1,1))
```
# Do we need to consider a first order difference of our residuals?
```{r}
par(mfrow=c(1,2))
acf(diff(e.ts.CO), main="Diff ACF of Residuals\nfrom CO.trend.seasonal")
pacf(diff(e.ts.CO),main="Diff PACF of Residuals\nfrom CO.trend.seasonal")
par(mfrow=c(1,1))
```
No, we do not need to differentiate the residuals of the CO.trend.seasonal model because the ACF shows decay with a lag of 3 and the differentiated ACF does not improve this. Thus, the value of d is 0.

# Plot the autocorrelation (ACF) and partial autocorrelation (PACF) of the residuals of NO2.trend.seasonal
```{r}
par(mfrow=c(1,2))
acf(e.ts.NO2, main="ACF of Residuals\nfrom NO2.trend.seasonal")
pacf(e.ts.NO2,main="PACF of Residuals\nfrom NO2.trend.seasonal")
par(mfrow=c(1,1))
```
# Do we need to consider a first order difference of our residuals?
```{r}
par(mfrow=c(1,2))
acf(diff(e.ts.NO2), main="Diff ACF of Residuals\nfrom NO2.trend.seasonal")
pacf(diff(e.ts.NO2),main="Diff PACF of Residuals\nfrom NO2.trend.seasonal")
par(mfrow=c(1,1))
```
Yes, we should consider a first order difference of our residuals here because the ACF of the original has positive autocorrelations out to a high number of lags (10). By taking the first order difference of the residuals, we reduce this number of lags to 3. Thus, the value of d is 1, to represent first order differentation.

# Choose p and q terms for e.ts.CO based on the acf and pacf 

# ar(1) p=1
```{r}
CO.ar1 <- arima(e.ts.CO, order=c(1,0,0), include.mean=FALSE)
summary(CO.ar1)
```
# ma(3) p=0, q=3
```{r}
CO.ma3 <- arima(e.ts.CO, order=c(0,0,3), include.mean=FALSE)
summary(CO.ma3)
```
# arma(1,3) p=1, q=3
```{r}
CO.arma13 <- arima(e.ts.CO, order=c(1,0,3), include.mean=FALSE)
summary(CO.arma13)
```
# use the auto.arima function on e.ts.CO
```{r}
CO.auto <- auto.arima(e.ts.CO,approximation=FALSE)
summary(CO.auto)
```

# Choose p and q terms for e.ts.NO2 based on the acf and pacf 

# ar(2) p=2
```{r}
NO2.ar1 <- arima(e.ts.NO2, order=c(2,1,0), include.mean=FALSE)
summary(NO2.ar1)
```
# ma(3) p=0, q=3
```{r}
NO2.ma10 <- arima(e.ts.NO2, order=c(0,1,3), include.mean=FALSE)
summary(NO2.ma10)
```
# arma(2,3) p=2, q=3
```{r}
NO2.arma23 <- arima(e.ts.NO2, order=c(2,1,3), include.mean=FALSE)
summary(NO2.arma23)
```
# use the auto.arima function on e.ts.NO@

```{r}
NO2.auto <- auto.arima(e.ts.NO2,approximation=FALSE)
summary(NO2.auto)
```
Is the auto.arima function always the right model to go with? how does it incorporate differencing?

# Part D: Assessment of Models
We used AIC and diagnostics to assess the models ....
```{r}
AIC(CO.ar1)
AIC(CO.ma3)
AIC(CO.arma13)
```
The lowest AIC is the CO.ar1, which is what the auto.arima function produced as well.

# Part E: Diagnostics
```{r}
tsdiag(CO.ar1, lag = 30)
```


### Part 2: Building Multivariate Time Series Models

## Part A: Seasonality
same as part 1a

## Part B: Trends
same as part 1b

## Part C: Auto-Regressive and Moving Average
```{r}
allResiduals <- data.frame(e.ts.CO, e.ts.NO2)
colnames(allResiduals) <- c("CO","NO2")
cor(allResiduals)
```
# Build VARMA model to CO and NO2 residuals
```{r, include=FALSE}
AICmatrix <- matrix(NA, 4, 5)
for(p in 1:4){
  for(q in 0:4){
    varma.model <- VARMACpp(allResiduals, p=p, q=q, include.mean=F)
    AICmatrix[p,q+1] <- varma.model$aic
  }
}
```
# Find which model has the lowest AIC
```{r}
AICmatrix
```
# Build the model with the lowest AIC
```{r}
varma.model <- VARMACpp(allResiduals, p=2, q=3, include.mean=F)
varma.model
MTSdiag(varma.model)
```

## Part D: Assessment of Models
```{r}

```

## Part E: Diagnostics
```{r}

```


### Part 3: Simulating from Univariate and Multivariate Time Series Models
```{r}
T.sim = VARMAsim(365,phi=varma.model$Phi,theta=varma.model$Theta,sigma=varma.model$Sigma)
```
## Part A: Ability to reproduce appearance
# Compare correlation of simulated residuals to actual residuals
```{r}
cor(T.sim$series)
cor(allResiduals)
```
# Plot observations and simulations


## Part B: Ability to reproduce observed trends
```{r}

```

## Part C: Ability to reproduce seasonality
```{r}

```

## Part D: Ability to reproduce observed mean and variance
```{r}

```

## Part E: Ability to reproduce auto-correlation
```{r}

```

## Part F: Ability to reproduce observed cross-correlation
```{r}

```
